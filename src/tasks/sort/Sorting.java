package tasks.sort;

/*
    складність алгоритмів :
    O(n) Це найпоширеніший спосіб представлення важкості алгоритму. Вона показує верхню межу виконання алгоритму в найгіршому випадку
    Константна: O(1) - алгоритм завжди виконується за однаковий час, незалежно від розміру вхідних даних.
    Лінійна: O(n) - час виконання алгоритму зростає лінійно зі збільшенням розміру вхідних даних.
    Логарифмічна: O(log n) - наприклад, бінарний пошук.
    Лінійно-логарифмічна: O(n log n) - наприклад, алгоритми сортування злиттям або швидке сортування в середньому випадку.
    Квадратична: O(n^2) - наприклад, прості алгоритми сортування, такі як сортування бульбашкою.
    Експоненціальна: O(2^n) - деякі задачі оптимізації, такі як задача про рюкзак.

 */
public class Sorting {
        public static void main(String[] args) {

        /*
            алгоритми сорторування :
            Бульбашкове сортування (Bubble Sort):
            Сортування вставками (Insertion Sort):
            Сортування вибором (Selection Sort):

         */
        /*
            Бульбашклве сортування :
             Опис: Бульбашкове сортування порівнює кожну пару сусідніх елементів у масиві і міняє їх місцями, якщо вони не впорядковані.
             Цей процес повторюється до тих пір, поки весь масив не буде відсортований.
         */
            int[] array = {5, 2, 8, 12, 1, 6};

            //System.out.println("Original array:");
            //printArray(array);

            //bubbleSort(array);

            //System.out.println("\nSorted array:");
            //(array);

        /*
            Сортування вставками (Insertion Sort)
            Сортування вставками включає вставку кожного елемента масиву на свою правильну позицію в вже відсортовану частину масиву.
            Таким чином, в кожній ітерації масив збільшується на один відсортований елемент.
         */
            //System.out.println("Original array:");
            //printArray(array);

            //insertionSort(array);

            //System.out.println("\nSorted array:");
            //printArray(array);

        /*
            Сортування вибором (Selection Sort):
            Сортування вибором вибирає найменший елемент з невідсортованої частини масиву і поміщає його
            на правильну позицію в відсортованій частині. Цей процес повторюється до тих пір, поки весь масив не буде відсортований.
         */

            //System.out.println("Original array:");
            //printArray(array);

            //selectionSort(array);

            //System.out.println("\nSorted array:");
            //printArray(array);

            printArray(array);
        }

        /*
            Квадратична важкість : O(n^2)

            Внутрішній цикл проходить через масив і порівнює кожну пару сусідніх елементів.
            Якщо поточний елемент більший за наступний, вони міняються місцями.
            Найбільші елементи "спливають" вправо під час кожної ітерації зовнішнього циклу.
            Процес повторюється до тих пір, поки всі елементи не будуть відсортовані.

            Приклади ітерацій :
            Приклад ітерацій та зміни масиву:
                Початковий масив: {5, 2, 8, 12, 1, 6}
                Перша ітерація: {2, 5, 8, 1, 6, 12}
                Друга ітерація: {2, 5, 1, 6, 8, 12}
                Третя ітерація: {2, 1, 5, 6, 8, 12}
                Четверта ітерація: {1, 2, 5, 6, 8, 12}
                Результат: {1, 2, 5, 6, 8, 12}
         */
        public static void bubbleSort(int[] array) {
            //int[] array = {5, 2, 8, 12, 1, 6};
            int n = array.length;
            for (int i = 0; i < n - 1; i++) {
                for (int j = 0; j < n - i - 1; j++) {
                    if (array[j] > array[j + 1]) {
                        int temp = array[j];
                        array[j] = array[j + 1];
                        array[j + 1] = temp;
                    }
                }
            }
        }

    /*
        Оптимізація: Якщо під час одного проходу не було здійснено жодного обміну, це означає,
        що масив вже відсортований. Ви можете додати логічну змінну, щоб перевірити це,
        і якщо обмінів не було, завершити сортування раніше.
   */
    public static void bubbleSortOptimazed(int[] array) {
        //int[] array = {5, 2, 8, 12, 1, 6};
        int n = array.length;
        boolean swapped;
        for (int i = 0; i < n - 1; i++) {
            swapped = false;
            for (int j = 0; j < n - i - 1; j++) {
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                    swapped = true;
                }
            }
            if (!swapped) break; // якщо обмінів не було, завершити сортування
        }
    }

    /*
        Має квадратичну важкість

        Зовнішній цикл проходить через масив, починаючи з другого елемента.
        Поточний елемент зберігається в змінній key.
        Внутрішній цикл здійснює зсув відсортованої частини масиву, зсуваючи елементи, які більші за key, вправо.
        Коли знайдено правильну позицію для key, він вставляється на цю позицію.

        Початковий масив: {5, 2, 8, 12, 1, 6}
        Перша ітерація: {2, 5, 8, 12, 1, 6}
        Друга ітерація: {2, 5, 8, 12, 1, 6}
        Третя ітерація: {2, 5, 8, 12, 1, 6}
        Четверта ітерація: {1, 2, 5, 8, 12, 6}
        П'ята ітерація: {1, 2, 5, 6, 8, 12}
        Результат: {1, 2, 5, 6, 8, 12}
     */
    public static void insertionSort(int[] array) {
        //int[] array = {5, 2, 8, 12, 1, 6};
        int n = array.length;
        for (int i = 1; i < n; i++) {
            int key = array[i];
            int j = i - 1;
            while (j >= 0 && array[j] > key) {
                array[j + 1] = array[j];
                j--;
            }
            array[j + 1] = key;
        }
    }

    /*
        має квадратичну важкість

        Зовнішній цикл проходить через масив.
        Змінна minIndex вказує на індекс найменшого елемента в невідсортованій частині масиву.
        Внутрішній цикл знаходить найменший елемент, порівнюючи його з усіма іншими елементами невідсортованої частини масиву.
        Знайдений найменший елемент міняється місцями з першим елементом невідсортованої частини.
        Процес повторюється до тих пір, поки всі елементи не будуть відсортовані.

        Початковий масив: {5, 2, 8, 12, 1, 6}
        Перша ітерація: {1, 2, 8, 12, 5, 6}
        Друга ітерація: {1, 2, 5, 12, 8, 6}
        Третя ітерація: {1, 2, 5, 6, 8, 12}
        Результат: {1, 2, 5, 6, 8, 12}
     */
        public static void selectionSort(int[] array) {
            int n = array.length;
            for (int i = 0; i < n - 1; i++) {
                int minIndex = i;
                for (int j = i + 1; j < n; j++) {
                    if (array[j] < array[minIndex]) {
                        minIndex = j;
                    }
                }
                int temp = array[minIndex];
                array[minIndex] = array[i];
                array[i] = temp;
            }
        }


        private static void selectionSortMyMin(int [] array){
            //sort by min
            int length = array.length;
            for (int i = 0; i < length - 1; i++) {
                int min = i;
                for (int j = i +1; j < length; j++) {
                    if (array[j] < array[min]) {
                        min = j;
                    }
                }
                int temp = array[min];
                array[min] = array[i];
                array[i] = temp;
            }

        }

    private static void selectionSortMyMax(int [] array){
        //sort by max
        int length = array.length;
        for (int i = 0; i < length - 1; i++) {
            int max = i;
            for (int j = i+1; j < length - 1; j++) {
                if (array[j] > array[max]) {
                    max = j;
                }
            }
            int temp = array[max];
            array[max] = array[i];
            array[i] = temp;
        }

    }


    //counting sort О(n+K)
    /*
        n — кількість елементів у вхідному масиві.
        k — розмах чисел у вхідному масиві, тобто різниця між максимальним та мінімальним значенням.

     */
    public static void countingSort(int[] array) {
        // 1. Знаходимо максимальне та мінімальне значення в масиві
        int max = array[0];
        int min = array[0];
        for (int i = 1; i < array.length; i++) {
            if (array[i] > max) {
                max = array[i];
            }
            if (array[i] < min) {
                min = array[i];
            }
        }

        // 2. Ініціалізуємо масив підрахунків
        int[] countArray = new int[max - min + 1];

        // 3. Підраховуємо кількість кожного елемента
        for (int i = 0; i < array.length; i++) {
            countArray[array[i] - min]++;
        }

        // 4. Відновлюємо відсортований масив
        int z = 0;
        for (int i = min; i <= max; i++) {
            while (countArray[i - min] > 0) {
                array[z] = i;
                z++;
                countArray[i - min]--;
            }
        }
    }

    /*
        QuickSort — це алгоритм сортування, який використовує стратегію "розділяй та володарюй".
        Основна ідея полягає в тому, щоб вибрати "опорний" елемент і розподілити масив на дві частини: елементи,
        менші за опорний, і елементи, більші за опорний. Потім рекурсивно сортувати ці дві частини.

        Найкращий випадок: O(n log n)
        Середній випадок: O(n log n)
        Найгірший випадок: O(n^2)

        Найкращий випадок (O(n log n)):

        Найкращий випадок для QuickSort виникає, коли опорний елемент, який ми вибираємо на кожному кроці,
        ділить масив на дві приблизно рівні частини. Це означає, що ми отримуємо максимальну ефективність
        "розділяй та володарюй" стратегії, і глибина рекурсивного дерева становить log n.

        Щоб досягти такого випадку, можна використовувати різні стратегії вибору опорного елемента, наприклад,
        вибирати середній елемент, або використовувати "медіану трьох" (де вибирається медіана першого, середнього та останнього елементів).

        Середній випадок (O(n log n)):

        Навіть якщо опорний елемент не завжди ділить масив на дві рівні частини,
         але розділення все ще є більш-менш збалансованим, алгоритм буде працювати з ефективністю, близькою до найкращого випадку.
         У середньому, якщо вибір опорного елемента відбувається випадковим чином, QuickSort буде мати часову важкість O(n log n).

        Найгірший випадок виникає, коли масив вже відсортований або відсортований у зворотному порядку,
        і опорний елемент є найбільшим або найменшим елементом на кожному кроці.
        Однак у багатьох реалізаціях використовуються стратегії вибору опорного елемента, які зменшують ймовірність найгіршого випадку.


        Рекурсія в QuickSort використовується для того, щоб застосувати той самий процес "партішенінгу" до підмасивів,
         які отримані після розбиття масиву відносно опорного елемента.

        Кожен виклик partition розділяє масив (або підмасив) на дві частини:

        Елементи менші за опорний.
        Елементи більші за опорний.
        Після цього, рекурсивно викликається quickSort для обох цих підмасивів.
        Це означає, що розмір підмасиву, який обробляється, зменшується з кожним рекурсивним викликом
        (хоча не завжди вдвічі, це залежить від вибору опорного елемента).

        Цей процес продовжується, доки підмасиви не стануть досить маленькими (зазвичай довжина 1 або 0),
        в такому випадку вони вважаються відсортованими за замовчуванням, і рекурсія завершується.

        Отже, рекурсія в QuickSort дозволяє нам застосовувати ту саму логіку розділення і сортування до все менших і менших підмасивів,
        доки весь масив не стане відсортованим.
     */


    // Головна функція для сортування
    public static void quickSort(int[] array, int low, int high) {
        if (low < high) {
            // Знаходимо індекс опорного елемента
            int pivotIndex = partition(array, low, high);

            // Рекурсивно сортуємо елементи до опорного
            quickSort(array, low, pivotIndex - 1);

            // Рекурсивно сортуємо елементи після опорного
            quickSort(array, pivotIndex + 1, high);
        }
    }

    // Функція для розбиття масиву на дві частини відносно опорного елемента
    /*
        Тут основна ідея полягає в тому, щоб розташувати опорний елемент на такому місці,
        що всі елементи, менші за нього, знаходяться ліворуч, а всі елементи,
         більші за нього, - праворуч. Змінна i вказує на останню позицію,
         де розташований елемент, менший за опорний. Тому, коли ми завершуємо цикл,
         ми розміщуємо опорний елемент після i, тобто на позиції i + 1.
     */
    private static int partition(int[] array, int low, int high) {
        // Вибираємо опорний елемент
        int pivot = array[high];

        // Індекс для розміщення опорного елемента на правильному місці.
        // Початково він встановлений перед першим елементом підмасиву.
        int i = (low - 1);

        for (int j = low; j < high; j++) {
            // Якщо поточний елемент менший за опорний
            if (array[j] < pivot) {
                i++;
                // Міняємо місцями елементи
                swap(array, i, j);
            }
        }

        // Розміщуємо опорний елемент на правильному місці (після всіх елементів, менших за нього)
        swap(array, i + 1, high);
        // Повертаємо індекс опорного елемента у відсортованому підмасиві
        return i + 1;
    }

    // Допоміжна функція для обміну елементів місцями
    private static void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    //покращення для квік сорту для виборки опорного елементу

    /*
        Як це працює: Виберіть медіану з першого, середнього та останнього елементів масиву як опорний.
        Реалізація: Знайдіть середній елемент і порівняйте ці три елементи, щоб визначити медіану. Потім обміняйте медіану з останнім елементом.
     */
    public static void quickSortMedianOfThree(int[] array, int low, int high) {
        if (low < high) {
            int pivotIndex = partitionMedianOfThree(array, low, high);
            quickSortMedianOfThree(array, low, pivotIndex - 1);
            quickSortMedianOfThree(array, pivotIndex + 1, high);
        }
    }

    private static int partitionMedianOfThree(int[] array, int low, int high) {
        int mid = low + (high - low) / 2;
        if (array[low] > array[mid])
            swap(array, low, mid);
        if (array[low] > array[high])
            swap(array, low, high);
        if (array[mid] > array[high])
            swap(array, mid, high);
        // Тепер медіана знаходиться на позиції `high`
        return partition(array, low, high);
    }


    /*
    Як це працює: Виберіть опорний елемент випадковим чином з масиву.
    Реалізація: Використовуйте генератор випадкових чисел для вибору індексу між low та high і використовуйте цей елемент як опорний.
     */
    public static void quickSortRandomPivot(int[] array, int low, int high) {
        if (low < high) {
            int pivotIndex = partitionRandomPivot(array, low, high);
            quickSortRandomPivot(array, low, pivotIndex - 1);
            quickSortRandomPivot(array, pivotIndex + 1, high);
        }
    }

    private static int partitionRandomPivot(int[] array, int low, int high) {
        int randomIndex = low + (int)(Math.random() * (high - low + 1));
        swap(array, randomIndex, high);
        return partition(array, low, high);
    }

    public static void printArray(int[] array) {
        for (int j : array) {
            System.out.print(j + " ");
        }
        System.out.println();
    }

    //про партішен
    /*
    "partition" в англійській мові означає "розділ" або "частина".
    У різних контекстах воно може мати специфічні відтінки значення, але основна ідея завжди полягає в розділенні чогось на частини.

    У QuickSort: "partition" вказує на процес розділення масиву на дві частини відносно опорного елемента.

    У Apache Kafka: "partition" це розділ або сегмент теми, який дозволяє Kafka масштабувати обробку повідомлень,
     розподіляючи дані між різними вузлами.

    У базах даних: "partitioning" вказує на розділення таблиці на менші, незалежні таблиці, але такі,
     які все ще представляються як одна логічна таблиця. Це робиться для покращення продуктивності та управління.

    У всіх цих випадках основна ідея полягає в розділенні більшого цілого на менші частини для ефективності, масштабування або управління.
     */


    //merge sort
    /*

    Логарифм з основою 2 від числа 20 (означається як log2 20) вказує на те,
    скільки разів число 2 потрібно піднести до певного степеня, щоб отримати 20.

    Математично це можна записати так:
    2^x = 20
    де x є значенням log2 20.

    Найкращий випадок: O(n log n)
    Середній випадок: O(n log n) - log n кількість рівнів рекурсії, тобто для 20 елементів лог 2 від 20 це +- 4,32 - тобто 5 рівнів
    Найгірший випадок: O(n log n)
    Просторова складність: O(n)

    формула обчислення буде :
        O(20 * log2 20)
        O(20 * 4.32)
        O(86.4)

    mergeSort: ця функція розділяє масив на дві частини, рекурсивно сортує їх, а потім зливає їх разом.
    merge: ця функція зливає два відсортовані підмасиви в один відсортований масив.
    Алгоритм сортування злиттям є стабільним, порівнювальним алгоритмом сортування, який працює за принципом "розділяй та володарюй".
     */
    public static void mergeSort(int[] array) {
        if (array.length <= 1) {
            return;
        }

        int mid = array.length / 2;

        int[] left = new int[mid];
        int[] right = new int[array.length - mid];

        // Розділення масиву на дві частини
        for (int i = 0; i < mid; i++) {
            left[i] = array[i];
        }
        for (int i = mid; i < array.length; i++) {
            right[i - mid] = array[i];
        }

        // Рекурсивний виклик для обох підмасивів
        mergeSort(left);
        mergeSort(right);

        // Злиття підмасивів
        merge(array, left, right);
    }

    public static void merge(int[] array, int[] left, int[] right) {
        int i = 0, j = 0, k = 0;

        // Поки обидва підмасиви мають елементи
        while (i < left.length && j < right.length) {
            if (left[i] <= right[j]) {
                array[k++] = left[i++];
            } else {
                array[k++] = right[j++];
            }
        }

        // Копіювання залишилися елементів з лівого підмасиву
        while (i < left.length) {
            array[k++] = left[i++];
        }

        // Копіювання залишилися елементів з правого підмасиву
        while (j < right.length) {
            array[k++] = right[j++];
        }
    }
}
